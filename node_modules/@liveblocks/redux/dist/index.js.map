{"version":3,"sources":["../src/index.ts","../src/errors.ts","../src/version.ts"],"names":["enterRoom","updates","leaveRoom"],"mappings":"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","sourcesContent":["import type {\n  BaseUserMeta,\n  JsonObject,\n  LiveObject,\n  LsonObject,\n  Room,\n  Status,\n  User,\n} from \"@liveblocks/client\";\nimport type { OpaqueClient, OpaqueRoom } from \"@liveblocks/core\";\nimport {\n  detectDupes,\n  legacy_patchImmutableObject,\n  lsonToJson,\n  patchLiveObjectKey,\n} from \"@liveblocks/core\";\nimport type { StoreEnhancer } from \"redux\";\n\nimport {\n  mappingShouldBeAnObject,\n  mappingShouldNotHaveTheSameKeys,\n  mappingToFunctionIsNotAllowed,\n  mappingValueShouldBeABoolean,\n  missingClient,\n} from \"./errors\";\nimport { PKG_FORMAT, PKG_NAME, PKG_VERSION } from \"./version\";\n\ndetectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);\n\nexport type Mapping<T> = {\n  [K in keyof T]?: boolean;\n};\n\nconst ACTION_TYPES = {\n  ENTER: \"@@LIVEBLOCKS/ENTER\",\n  LEAVE: \"@@LIVEBLOCKS/LEAVE\",\n  START_LOADING_STORAGE: \"@@LIVEBLOCKS/START_LOADING_STORAGE\",\n  INIT_STORAGE: \"@@LIVEBLOCKS/INIT_STORAGE\",\n  PATCH_REDUX_STATE: \"@@LIVEBLOCKS/PATCH_REDUX_STATE\",\n  UPDATE_CONNECTION: \"@@LIVEBLOCKS/UPDATE_CONNECTION\",\n  UPDATE_OTHERS: \"@@LIVEBLOCKS/UPDATE_OTHERS\",\n};\n\ntype LiveblocksContext<P extends JsonObject, U extends BaseUserMeta> = {\n  /**\n   * Other users in the room. Empty no room is currently synced\n   */\n  readonly others: readonly User<P, U>[];\n  /**\n   * Whether or not the room storage is currently loading\n   */\n  readonly isStorageLoading: boolean;\n  /**\n   * Connection status of the room.\n   */\n  readonly status: Status;\n};\n\n/**\n * Adds the `liveblocks` property to your custom Redux state.\n */\nexport type WithLiveblocks<\n  TState,\n  P extends JsonObject,\n  U extends BaseUserMeta,\n> = TState & { readonly liveblocks: LiveblocksContext<P, U> };\n\nconst internalEnhancer = <TState>(options: {\n  client: OpaqueClient;\n  storageMapping?: Mapping<TState>;\n  presenceMapping?: Mapping<TState>;\n}) => {\n  if (process.env.NODE_ENV !== \"production\" && options.client == null) {\n    throw missingClient();\n  }\n  const client = options.client;\n  const mapping = validateMapping(\n    options.storageMapping || {},\n    \"storageMapping\"\n  );\n  const presenceMapping = validateMapping(\n    options.presenceMapping || {},\n    \"presenceMapping\"\n  );\n  if (process.env.NODE_ENV !== \"production\") {\n    validateNoDuplicateKeys(mapping, presenceMapping);\n  }\n\n  return (createStore: any) => {\n    return (reducer: any, initialState: any, enhancer: any) => {\n      let maybeRoom: OpaqueRoom | null = null;\n      let isPatching: boolean = false;\n      let storageRoot: LiveObject<LsonObject> | null = null;\n      let unsubscribeCallbacks: Array<() => void> = [];\n      let lastRoomId: string | null = null;\n      let lastLeaveFn: (() => void) | null = null;\n\n      const newReducer = (state: any, action: any) => {\n        switch (action.type) {\n          case ACTION_TYPES.PATCH_REDUX_STATE:\n            return {\n              ...state,\n              ...action.state,\n            };\n          case ACTION_TYPES.INIT_STORAGE:\n            return {\n              ...state,\n              ...action.state,\n              liveblocks: {\n                ...state.liveblocks,\n                isStorageLoading: false,\n              },\n            };\n          case ACTION_TYPES.START_LOADING_STORAGE:\n            return {\n              ...state,\n              liveblocks: {\n                ...state.liveblocks,\n                isStorageLoading: true,\n              },\n            };\n          case ACTION_TYPES.UPDATE_CONNECTION: {\n            return {\n              ...state,\n              liveblocks: {\n                ...state.liveblocks,\n                connection: action.connection,\n                status: action.status,\n              },\n            };\n          }\n          case ACTION_TYPES.UPDATE_OTHERS: {\n            return {\n              ...state,\n              liveblocks: {\n                ...state.liveblocks,\n                others: action.others,\n              },\n            };\n          }\n          default: {\n            const newState = reducer(state, action);\n\n            if (maybeRoom) {\n              isPatching = true;\n              updatePresence(\n                maybeRoom,\n                state,\n                newState,\n                presenceMapping as any\n              );\n\n              maybeRoom.batch(() => {\n                if (storageRoot) {\n                  patchLiveblocksStorage(\n                    storageRoot,\n                    state,\n                    newState,\n                    mapping as any\n                  );\n                }\n              });\n              isPatching = false;\n            }\n\n            if (newState.liveblocks == null) {\n              return {\n                ...newState,\n                liveblocks: {\n                  others: [],\n                  isStorageLoading: false,\n                  connection: \"closed\",\n                  status: \"initial\",\n                },\n              };\n            }\n            return newState;\n          }\n        }\n      };\n\n      const store = createStore(newReducer, initialState, enhancer);\n\n      function enterRoom(newRoomId: string): void {\n        if (lastRoomId === newRoomId) {\n          return;\n        }\n\n        lastRoomId = newRoomId;\n        if (lastLeaveFn !== null) {\n          // First leave the old room before entering a potential new one\n          lastLeaveFn();\n        }\n\n        const initialPresence = selectFields(\n          store.getState(),\n          presenceMapping\n        ) as any;\n\n        const { room, leave } = client.enterRoom(newRoomId, {\n          initialPresence,\n        });\n        maybeRoom = room as OpaqueRoom;\n\n        unsubscribeCallbacks.push(\n          room.events.status.subscribe((status) => {\n            store.dispatch({\n              type: ACTION_TYPES.UPDATE_CONNECTION,\n              status,\n            });\n          })\n        );\n\n        unsubscribeCallbacks.push(\n          room.events.others.subscribe(({ others }) => {\n            store.dispatch({\n              type: ACTION_TYPES.UPDATE_OTHERS,\n              others,\n            });\n          })\n        );\n\n        unsubscribeCallbacks.push(\n          room.events.myPresence.subscribe(() => {\n            if (isPatching === false) {\n              store.dispatch({\n                type: ACTION_TYPES.PATCH_REDUX_STATE,\n                state: selectFields(room.getPresence(), presenceMapping),\n              });\n            }\n          })\n        );\n\n        store.dispatch({\n          type: ACTION_TYPES.START_LOADING_STORAGE,\n        });\n\n        void room.getStorage().then(({ root }) => {\n          const updates: any = {};\n\n          maybeRoom!.batch(() => {\n            for (const key in mapping) {\n              const liveblocksStatePart = root.get(key);\n\n              if (liveblocksStatePart == null) {\n                updates[key] = store.getState()[key];\n                patchLiveObjectKey(root, key, undefined, store.getState()[key]);\n              } else {\n                updates[key] = lsonToJson(liveblocksStatePart);\n              }\n            }\n          });\n\n          store.dispatch({\n            type: ACTION_TYPES.INIT_STORAGE,\n            state: updates,\n          });\n\n          storageRoot = root;\n          unsubscribeCallbacks.push(\n            maybeRoom!.subscribe(\n              root,\n              (updates) => {\n                if (isPatching === false) {\n                  store.dispatch({\n                    type: ACTION_TYPES.PATCH_REDUX_STATE,\n                    state: patchState(\n                      store.getState(),\n                      updates,\n                      mapping as any\n                    ),\n                  });\n                }\n              },\n              { isDeep: true }\n            )\n          );\n        });\n\n        lastLeaveFn = () => {\n          for (const unsubscribe of unsubscribeCallbacks) {\n            unsubscribe();\n          }\n          unsubscribeCallbacks = [];\n\n          storageRoot = null;\n          maybeRoom = null;\n          isPatching = false;\n\n          lastRoomId = null;\n          lastLeaveFn = null;\n          leave();\n        };\n      }\n\n      function leaveRoom() {\n        lastLeaveFn?.();\n      }\n\n      function newDispatch(action: any) {\n        if (action.type === ACTION_TYPES.ENTER) {\n          enterRoom(action.roomId);\n        } else if (action.type === ACTION_TYPES.LEAVE) {\n          leaveRoom();\n        } else {\n          store.dispatch(action);\n        }\n      }\n\n      return {\n        ...store,\n        dispatch: newDispatch,\n      };\n    };\n  };\n};\n\n/**\n * Actions used to interact with Liveblocks\n */\nexport const actions = {\n  /**\n   * Enters a room and starts sync it with Redux state\n   * @param roomId The id of the room\n   */\n  enterRoom,\n  /**\n   * Leaves the currently entered room and stops sync it with Redux state.\n   */\n  leaveRoom,\n};\n\nfunction enterRoom(roomId: string): {\n  type: string;\n  roomId: string;\n} {\n  return {\n    type: ACTION_TYPES.ENTER,\n    roomId,\n  };\n}\n\nfunction leaveRoom(): {\n  type: string;\n} {\n  return { type: ACTION_TYPES.LEAVE };\n}\n\n/**\n * Redux store enhancer that will make the `liveblocks` key available on your\n * Redux store.\n */\nexport const liveblocksEnhancer = internalEnhancer as <TState>(options: {\n  client: OpaqueClient;\n  storageMapping?: Mapping<TState>;\n  presenceMapping?: Mapping<TState>;\n}) => StoreEnhancer;\n\nfunction patchLiveblocksStorage<O extends LsonObject, TState>(\n  root: LiveObject<O>,\n  oldState: TState,\n  newState: TState,\n  mapping: Mapping<TState>\n) {\n  for (const key in mapping) {\n    if (\n      process.env.NODE_ENV !== \"production\" &&\n      typeof newState[key] === \"function\"\n    ) {\n      throw mappingToFunctionIsNotAllowed(\"value\");\n    }\n\n    if (oldState[key] !== newState[key]) {\n      const oldVal = oldState[key];\n      const newVal = newState[key];\n      patchLiveObjectKey(root, key, oldVal as any, newVal);\n    }\n  }\n}\n\nfunction updatePresence<P extends JsonObject>(\n  room: Room<P, any, any, any, any>,\n  oldState: P,\n  newState: P,\n  presenceMapping: Mapping<P>\n) {\n  for (const key in presenceMapping) {\n    if (typeof newState[key] === \"function\") {\n      throw mappingToFunctionIsNotAllowed(\"value\");\n    }\n\n    if (oldState[key] !== newState[key]) {\n      room.updatePresence({ [key]: newState[key] } as P);\n    }\n  }\n}\n\nfunction isObject(value: any): value is object {\n  return Object.prototype.toString.call(value) === \"[object Object]\";\n}\n\nfunction validateNoDuplicateKeys<TState>(\n  storageMapping: Mapping<TState>,\n  presenceMapping: Mapping<TState>\n) {\n  for (const key in storageMapping) {\n    if (presenceMapping[key] !== undefined) {\n      throw mappingShouldNotHaveTheSameKeys(key);\n    }\n  }\n}\n\nfunction selectFields<TState>(\n  presence: TState,\n  mapping: Mapping<TState>\n): /* TODO: Actually, Pick<TState, keyof Mapping<TState>> ? */\nPartial<TState> {\n  const partialState = {} as Partial<TState>;\n  for (const key in mapping) {\n    partialState[key] = presence[key];\n  }\n  return partialState;\n}\n\nfunction patchState<TState extends JsonObject>(\n  state: TState,\n  updates: any[], // StorageUpdate\n  mapping: Mapping<TState>\n) {\n  const partialState: Partial<TState> = {};\n\n  for (const key in mapping) {\n    partialState[key] = state[key];\n  }\n\n  const patched = legacy_patchImmutableObject(partialState, updates);\n\n  const result: Partial<TState> = {};\n\n  for (const key in mapping) {\n    result[key] = patched[key];\n  }\n\n  return result;\n}\n\n/**\n * Remove false keys from mapping and generate to a new object to avoid potential mutation from outside the middleware\n */\nfunction validateMapping<TState>(\n  mapping: Mapping<TState>,\n  mappingType: \"storageMapping\" | \"presenceMapping\"\n): Mapping<TState> {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!isObject(mapping)) {\n      throw mappingShouldBeAnObject(mappingType);\n    }\n  }\n\n  const result: Mapping<TState> = {};\n  for (const key in mapping) {\n    if (\n      process.env.NODE_ENV !== \"production\" &&\n      typeof mapping[key] !== \"boolean\"\n    ) {\n      throw mappingValueShouldBeABoolean(mappingType, key);\n    }\n\n    if (mapping[key] === true) {\n      result[key] = true;\n    }\n  }\n  return result;\n}\n","export const ERROR_PREFIX = \"Invalid @liveblocks/redux middleware config.\";\n\nexport function missingClient(): Error {\n  return new Error(`${ERROR_PREFIX} client is missing`);\n}\n\nexport function mappingShouldBeAnObject(\n  mappingType: \"storageMapping\" | \"presenceMapping\"\n): Error {\n  return new Error(\n    `${ERROR_PREFIX} ${mappingType} should be an object where the values are boolean.`\n  );\n}\n\nexport function mappingValueShouldBeABoolean(\n  mappingType: \"storageMapping\" | \"presenceMapping\",\n  key: string\n): Error {\n  return new Error(\n    `${ERROR_PREFIX} ${mappingType}.${key} value should be a boolean`\n  );\n}\n\nexport function mappingShouldNotHaveTheSameKeys(key: string): Error {\n  return new Error(\n    `${ERROR_PREFIX} \"${key}\" is mapped on presenceMapping and storageMapping. A key shouldn't exist on both mapping.`\n  );\n}\n\nexport function mappingToFunctionIsNotAllowed(key: string): Error {\n  return new Error(\n    `${ERROR_PREFIX} mapping.${key} is invalid. Mapping to a function is not allowed.`\n  );\n}\n","declare const __VERSION__: string;\ndeclare const TSUP_FORMAT: string;\n\nexport const PKG_NAME = \"@liveblocks/redux\";\nexport const PKG_VERSION = typeof __VERSION__ === \"string\" && __VERSION__;\nexport const PKG_FORMAT = typeof TSUP_FORMAT === \"string\" && TSUP_FORMAT;\n"]}