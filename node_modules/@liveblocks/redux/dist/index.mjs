// src/index.ts
import {
  detectDupes,
  legacy_patchImmutableObject,
  lsonToJson,
  patchLiveObjectKey
} from "@liveblocks/core";

// src/errors.ts
var ERROR_PREFIX = "Invalid @liveblocks/redux middleware config.";
function missingClient() {
  return new Error(`${ERROR_PREFIX} client is missing`);
}
function mappingShouldBeAnObject(mappingType) {
  return new Error(
    `${ERROR_PREFIX} ${mappingType} should be an object where the values are boolean.`
  );
}
function mappingValueShouldBeABoolean(mappingType, key) {
  return new Error(
    `${ERROR_PREFIX} ${mappingType}.${key} value should be a boolean`
  );
}
function mappingShouldNotHaveTheSameKeys(key) {
  return new Error(
    `${ERROR_PREFIX} "${key}" is mapped on presenceMapping and storageMapping. A key shouldn't exist on both mapping.`
  );
}
function mappingToFunctionIsNotAllowed(key) {
  return new Error(
    `${ERROR_PREFIX} mapping.${key} is invalid. Mapping to a function is not allowed.`
  );
}

// src/version.ts
var PKG_NAME = "@liveblocks/redux";
var PKG_VERSION = "2.1.0";
var PKG_FORMAT = "esm";

// src/index.ts
detectDupes(PKG_NAME, PKG_VERSION, PKG_FORMAT);
var ACTION_TYPES = {
  ENTER: "@@LIVEBLOCKS/ENTER",
  LEAVE: "@@LIVEBLOCKS/LEAVE",
  START_LOADING_STORAGE: "@@LIVEBLOCKS/START_LOADING_STORAGE",
  INIT_STORAGE: "@@LIVEBLOCKS/INIT_STORAGE",
  PATCH_REDUX_STATE: "@@LIVEBLOCKS/PATCH_REDUX_STATE",
  UPDATE_CONNECTION: "@@LIVEBLOCKS/UPDATE_CONNECTION",
  UPDATE_OTHERS: "@@LIVEBLOCKS/UPDATE_OTHERS"
};
var internalEnhancer = (options) => {
  if (process.env.NODE_ENV !== "production" && options.client == null) {
    throw missingClient();
  }
  const client = options.client;
  const mapping = validateMapping(
    options.storageMapping || {},
    "storageMapping"
  );
  const presenceMapping = validateMapping(
    options.presenceMapping || {},
    "presenceMapping"
  );
  if (process.env.NODE_ENV !== "production") {
    validateNoDuplicateKeys(mapping, presenceMapping);
  }
  return (createStore) => {
    return (reducer, initialState, enhancer) => {
      let maybeRoom = null;
      let isPatching = false;
      let storageRoot = null;
      let unsubscribeCallbacks = [];
      let lastRoomId = null;
      let lastLeaveFn = null;
      const newReducer = (state, action) => {
        switch (action.type) {
          case ACTION_TYPES.PATCH_REDUX_STATE:
            return {
              ...state,
              ...action.state
            };
          case ACTION_TYPES.INIT_STORAGE:
            return {
              ...state,
              ...action.state,
              liveblocks: {
                ...state.liveblocks,
                isStorageLoading: false
              }
            };
          case ACTION_TYPES.START_LOADING_STORAGE:
            return {
              ...state,
              liveblocks: {
                ...state.liveblocks,
                isStorageLoading: true
              }
            };
          case ACTION_TYPES.UPDATE_CONNECTION: {
            return {
              ...state,
              liveblocks: {
                ...state.liveblocks,
                connection: action.connection,
                status: action.status
              }
            };
          }
          case ACTION_TYPES.UPDATE_OTHERS: {
            return {
              ...state,
              liveblocks: {
                ...state.liveblocks,
                others: action.others
              }
            };
          }
          default: {
            const newState = reducer(state, action);
            if (maybeRoom) {
              isPatching = true;
              updatePresence(
                maybeRoom,
                state,
                newState,
                presenceMapping
              );
              maybeRoom.batch(() => {
                if (storageRoot) {
                  patchLiveblocksStorage(
                    storageRoot,
                    state,
                    newState,
                    mapping
                  );
                }
              });
              isPatching = false;
            }
            if (newState.liveblocks == null) {
              return {
                ...newState,
                liveblocks: {
                  others: [],
                  isStorageLoading: false,
                  connection: "closed",
                  status: "initial"
                }
              };
            }
            return newState;
          }
        }
      };
      const store = createStore(newReducer, initialState, enhancer);
      function enterRoom2(newRoomId) {
        if (lastRoomId === newRoomId) {
          return;
        }
        lastRoomId = newRoomId;
        if (lastLeaveFn !== null) {
          lastLeaveFn();
        }
        const initialPresence = selectFields(
          store.getState(),
          presenceMapping
        );
        const { room, leave } = client.enterRoom(newRoomId, {
          initialPresence
        });
        maybeRoom = room;
        unsubscribeCallbacks.push(
          room.events.status.subscribe((status) => {
            store.dispatch({
              type: ACTION_TYPES.UPDATE_CONNECTION,
              status
            });
          })
        );
        unsubscribeCallbacks.push(
          room.events.others.subscribe(({ others }) => {
            store.dispatch({
              type: ACTION_TYPES.UPDATE_OTHERS,
              others
            });
          })
        );
        unsubscribeCallbacks.push(
          room.events.myPresence.subscribe(() => {
            if (isPatching === false) {
              store.dispatch({
                type: ACTION_TYPES.PATCH_REDUX_STATE,
                state: selectFields(room.getPresence(), presenceMapping)
              });
            }
          })
        );
        store.dispatch({
          type: ACTION_TYPES.START_LOADING_STORAGE
        });
        void room.getStorage().then(({ root }) => {
          const updates = {};
          maybeRoom.batch(() => {
            for (const key in mapping) {
              const liveblocksStatePart = root.get(key);
              if (liveblocksStatePart == null) {
                updates[key] = store.getState()[key];
                patchLiveObjectKey(root, key, void 0, store.getState()[key]);
              } else {
                updates[key] = lsonToJson(liveblocksStatePart);
              }
            }
          });
          store.dispatch({
            type: ACTION_TYPES.INIT_STORAGE,
            state: updates
          });
          storageRoot = root;
          unsubscribeCallbacks.push(
            maybeRoom.subscribe(
              root,
              (updates2) => {
                if (isPatching === false) {
                  store.dispatch({
                    type: ACTION_TYPES.PATCH_REDUX_STATE,
                    state: patchState(
                      store.getState(),
                      updates2,
                      mapping
                    )
                  });
                }
              },
              { isDeep: true }
            )
          );
        });
        lastLeaveFn = () => {
          for (const unsubscribe of unsubscribeCallbacks) {
            unsubscribe();
          }
          unsubscribeCallbacks = [];
          storageRoot = null;
          maybeRoom = null;
          isPatching = false;
          lastRoomId = null;
          lastLeaveFn = null;
          leave();
        };
      }
      function leaveRoom2() {
        lastLeaveFn?.();
      }
      function newDispatch(action) {
        if (action.type === ACTION_TYPES.ENTER) {
          enterRoom2(action.roomId);
        } else if (action.type === ACTION_TYPES.LEAVE) {
          leaveRoom2();
        } else {
          store.dispatch(action);
        }
      }
      return {
        ...store,
        dispatch: newDispatch
      };
    };
  };
};
var actions = {
  /**
   * Enters a room and starts sync it with Redux state
   * @param roomId The id of the room
   */
  enterRoom,
  /**
   * Leaves the currently entered room and stops sync it with Redux state.
   */
  leaveRoom
};
function enterRoom(roomId) {
  return {
    type: ACTION_TYPES.ENTER,
    roomId
  };
}
function leaveRoom() {
  return { type: ACTION_TYPES.LEAVE };
}
var liveblocksEnhancer = internalEnhancer;
function patchLiveblocksStorage(root, oldState, newState, mapping) {
  for (const key in mapping) {
    if (process.env.NODE_ENV !== "production" && typeof newState[key] === "function") {
      throw mappingToFunctionIsNotAllowed("value");
    }
    if (oldState[key] !== newState[key]) {
      const oldVal = oldState[key];
      const newVal = newState[key];
      patchLiveObjectKey(root, key, oldVal, newVal);
    }
  }
}
function updatePresence(room, oldState, newState, presenceMapping) {
  for (const key in presenceMapping) {
    if (typeof newState[key] === "function") {
      throw mappingToFunctionIsNotAllowed("value");
    }
    if (oldState[key] !== newState[key]) {
      room.updatePresence({ [key]: newState[key] });
    }
  }
}
function isObject(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
}
function validateNoDuplicateKeys(storageMapping, presenceMapping) {
  for (const key in storageMapping) {
    if (presenceMapping[key] !== void 0) {
      throw mappingShouldNotHaveTheSameKeys(key);
    }
  }
}
function selectFields(presence, mapping) {
  const partialState = {};
  for (const key in mapping) {
    partialState[key] = presence[key];
  }
  return partialState;
}
function patchState(state, updates, mapping) {
  const partialState = {};
  for (const key in mapping) {
    partialState[key] = state[key];
  }
  const patched = legacy_patchImmutableObject(partialState, updates);
  const result = {};
  for (const key in mapping) {
    result[key] = patched[key];
  }
  return result;
}
function validateMapping(mapping, mappingType) {
  if (process.env.NODE_ENV !== "production") {
    if (!isObject(mapping)) {
      throw mappingShouldBeAnObject(mappingType);
    }
  }
  const result = {};
  for (const key in mapping) {
    if (process.env.NODE_ENV !== "production" && typeof mapping[key] !== "boolean") {
      throw mappingValueShouldBeABoolean(mappingType, key);
    }
    if (mapping[key] === true) {
      result[key] = true;
    }
  }
  return result;
}
export {
  actions,
  liveblocksEnhancer
};
//# sourceMappingURL=index.mjs.map